import { Component, Element, Event, EventEmitter, h, Host, Prop, State } from '@stencil/core';
import { strToRGBA, RGBAtoHSVA, RGBAToHex, } from './color-utils';
import { background } from 'storybook/internal/theming';

@Component({
    tag: 'color-picker-a',
    styleUrls: ['color-picker.scss'],
    shadow: true,
})
export class ColorPicker {
    @Prop()
    color: string = '#ff0000';

    @Prop({ mutable: true })
    swatches: string[] = [];

    @Prop()
    editMode: boolean = false;

    @Element() el: HTMLElement;

    @Event({ eventName: "colorChange" })
    colorChange: EventEmitter<string>;

    @Event({ eventName: "colorSelected" })
    colorSelected: EventEmitter<string>;


    @Event({ eventName: "colorAdded" })
    colorAdded: EventEmitter<string>;

    // Element references using ref pattern
    private colorArea: HTMLElement;
    private colorMarker: HTMLElement;
    private hueSlider: HTMLInputElement;
    private hueMarker: HTMLElement;
    private alphaSlider: HTMLInputElement;
    private alphaMarker: HTMLElement;
    private alphaGradient: HTMLElement; // Added reference to alpha gradient span
    private colorPreview: HTMLElement;
    private colorValue: HTMLInputElement;
    private pickerEl: HTMLElement;

    // Private variables that don't trigger renders
    private colorAreaDims = { width: 0, height: 0, x: 0, y: 0 };
    private isPointerDown: boolean = false;
    private initializing: boolean = true;
    private defaultMarkerPosition = { s: 100, v: 100 };
    private markerPosition = { x: 0, y: 0 };
    // States
    @State()
    hue: number = 0;
    @State()
    alpha: number = 1;
    @State()
    currentColor: string = '';
    @State()
    hexColor: string = '#ff0000';
    @State()
    opaqueHexColor: string = '#ff0000';

    componentWillLoad() {
        if (this.color) {
            const rgba = strToRGBA(this.color);
            const hsva = RGBAtoHSVA(rgba);
            this.hue = hsva.h;
            this.alpha = hsva.a;
            this.hexColor = RGBAToHex(rgba);
            this.opaqueHexColor = this.hexColor.substring(0, 7);
            this.currentColor = this.color;
            this.defaultMarkerPosition = {
                s: hsva.s,
                v: hsva.v,
            };
        }
    }

    componentDidLoad() {
        this.updateColorAreaDimensions();
        if (this.initializing) {
            const x = (this.defaultMarkerPosition.s / 100) * this.colorAreaDims.width;
            const y = (1 - this.defaultMarkerPosition.v / 100) * this.colorAreaDims.height;

            if (this.colorMarker) {
                this.colorMarker.style.left = `${x}px`;
                this.colorMarker.style.top = `${y}px`;
            }
            this.markerPosition = { x, y };
            this.updateInitialUI();
            this.initializing = false;
        }

        // Add event listeners
        this.attachEventListeners();
    }

    updateInitialUI() {
        // Update UI elements based on the current state without changing state
        if (this.hueSlider) {
            this.hueSlider.value = this.hue.toString();
        }

        if (this.alphaSlider) {
            this.alphaSlider.value = (this.alpha * 100).toString();
        }

        if (this.hueMarker) {
            this.hueMarker.style.left = `${(this.hue / 360) * 100}%`;
        }

        if (this.pickerEl) {
            this.pickerEl.style.color = `hsl(${this.hue}, 100%, 50%)`;
        }

        if (this.alphaMarker) {
            this.alphaMarker.style.left = `${this.alpha * 100}%`;

            this.alphaMarker.style.color = this.hexColor;

            if (this.alphaMarker.parentNode) {
                const alphaSliderParent = this.alphaMarker.parentNode as HTMLElement;
                alphaSliderParent.style.color = this.opaqueHexColor;
            }
        }

        // Update the alpha gradient span
        if (this.alphaGradient) {
            // Force repaint for Chrome bug workaround
            this.forceGradientRepaint();
        }

        if (this.colorMarker) {
            this.colorMarker.style.color = this.opaqueHexColor;
        }

        if (this.colorPreview) {
            this.colorPreview.style.color = this.hexColor;
        }

        if (this.colorValue) {
            this.colorValue.value = this.hexColor;
        }
    }

    // Force repaint of gradients (for Chrome bug workaround)
    forceGradientRepaint() {
        // Force repaint the color gradient
        if (this.colorArea) {
            this.colorArea.style.display = 'none';
            this.colorArea.offsetHeight; // Trigger reflow
            this.colorArea.style.display = '';
        }

        // Force repaint the alpha gradient
        if (this.alphaGradient) {
            this.alphaGradient.style.display = 'none';
            this.alphaGradient.offsetHeight; // Trigger reflow
            this.alphaGradient.style.display = '';
        }
    }

    handleColorAreaPointerUp = () => {
        this.colorSelected.emit(this.hexColor);
    }

    attachEventListeners() {
        // Add event listeners for color area and marker using pointer events
        if (this.colorArea) {
            this.colorArea.addEventListener('pointerdown', this.handleColorAreaPointerDown);
            this.colorArea.addEventListener('pointerup', this.handleColorAreaPointerUp);
        }

        if (this.colorMarker) {
            this.colorMarker.addEventListener('pointerdown', this.handleMarkerPointerDown);
        }

        // Add event listener for sliders
        if (this.hueSlider) {
            this.hueSlider.addEventListener('input', this.handleHueChange);
        }

        if (this.alphaSlider) {
            this.alphaSlider.addEventListener('input', this.handleAlphaChange);
        }

        // Add event listener for color input
        if (this.colorValue) {
            this.colorValue.addEventListener('change', this.handleColorInputChange);
        }

        // Global event listeners for pointer events
        document.addEventListener('pointermove', this.handlePointerMove);
        document.addEventListener('pointerup', this.handlePointerUp);
        document.addEventListener('pointercancel', this.handlePointerUp);
    }

    disconnectedCallback() {
        // Clean up event listeners
        document.removeEventListener('pointermove', this.handlePointerMove);
        document.removeEventListener('pointerup', this.handlePointerUp);
        document.removeEventListener('pointercancel', this.handlePointerUp);

        if (this.colorArea) {
            this.colorArea.removeEventListener('pointerdown', this.handleColorAreaPointerDown);
            this.colorArea.removeEventListener('pointerup', this.handleColorAreaPointerUp);
        }

        if (this.colorMarker) {
            this.colorMarker.removeEventListener('pointerdown', this.handleMarkerPointerDown);
        }

        if (this.hueSlider) {
            this.hueSlider.removeEventListener('input', this.handleHueChange);
        }

        if (this.alphaSlider) {
            this.alphaSlider.removeEventListener('input', this.handleAlphaChange);
        }

        if (this.colorValue) {
            this.colorValue.removeEventListener('change', this.handleColorInputChange);
        }
    }

    handleHueChange = () => {
        this.hue = parseInt(this.hueSlider.value, 10);
        this.updateHueUI();
        this.updateColorFromPosition();
    };

    handleAlphaChange = () => {
        this.alpha = parseInt(this.alphaSlider.value, 10) / 100;
        this.updateAlphaUI();
        this.updateColorFromPosition();
    };

    handleColorInputChange = () => {
        const colorStr = this.colorValue.value;
        this.setColorFromStr(colorStr);
    };

    setColorFromStr = (colorStr: string) => {
        // Parse the color string to get rgba values
        const rgba = strToRGBA(colorStr);
        const hsva = RGBAtoHSVA(rgba);

        // Update state values
        this.hue = hsva.h;
        this.alpha = hsva.a;

        // Update UI elements
        if (this.hueSlider) {
            this.hueSlider.value = this.hue.toString();
        }

        if (this.alphaSlider) {
            this.alphaSlider.value = (this.alpha * 100).toString();
        }

        // Calculate the marker position based on hsv
        if (this.colorAreaDims.width > 0 && this.colorAreaDims.height > 0) {
            const x = (hsva.s / 100) * this.colorAreaDims.width;
            const y = (1 - hsva.v / 100) * this.colorAreaDims.height;
            this.markerPosition = { x, y };
        }

        // Update UI
        this.updateHueUI();
        this.updateMarkerPosition();
        this.updateColorFromPosition();
    };


    updateHueUI = () => {
        // Update the hue marker position
        if (this.hueMarker) {
            this.hueMarker.style.left = `${(this.hue / 360) * 100}%`;
        }

        // Update the color of the picker (affects the gradient)
        if (this.pickerEl) {
            this.pickerEl.style.color = `hsl(${this.hue}, 100%, 50%)`;
        }
    };

    updateAlphaUI = () => {
        // Update the alpha marker position
        if (this.alphaMarker) {
            this.alphaMarker.style.left = `${this.alpha * 100}%`;
        }

        // Update the alpha slider's background color and marker
        if (this.alphaMarker && this.alphaMarker.parentNode) {
            const alphaSliderParent = this.alphaMarker.parentNode as HTMLElement;
            // Use the opaque version of the current color (exactly like coloris.js does)
            alphaSliderParent.style.color = this.opaqueHexColor;

            // Set the alpha marker color to show the full color with transparency
            this.alphaMarker.style.color = this.hexColor;
        }

        // Force repaint the alpha gradient span (Chrome bug workaround)
        if (this.alphaGradient) {
            this.alphaGradient.style.display = 'none';
            this.alphaGradient.offsetHeight; // Trigger reflow
            this.alphaGradient.style.display = '';
        }
    };

    updateColorPreview = () => {
        if (this.colorPreview) {
            this.colorPreview.style.color = this.hexColor;
        }

        // Update hex color value input
        if (this.colorValue) {
            this.colorValue.value = this.hexColor;
        }
    };

    getCurrentHSV = () => {
        // If color area dimensions aren't initialized yet, use default values
        if (this.colorAreaDims.width === 0 || this.colorAreaDims.height === 0) {
            return {
                h: this.hue,
                s: this.defaultMarkerPosition.s || 100,
                v: this.defaultMarkerPosition.v || 100,
            };
        }

        // Calculate saturation and value based on marker position
        const s = (this.markerPosition.x / this.colorAreaDims.width) * 100;
        const v = 100 - (this.markerPosition.y / this.colorAreaDims.height) * 100;
        return { h: this.hue, s, v };
    };

    updateColorAreaDimensions = () => {
        if (!this.colorArea) return;

        const rect = this.colorArea.getBoundingClientRect();
        this.colorAreaDims = {
            width: this.colorArea.offsetWidth,
            height: this.colorArea.offsetHeight,
            x: rect.left,
            y: rect.top,
        };
    };

    getPointerPosition = (event: PointerEvent) => {
        return {
            pageX: event.pageX,
            pageY: event.pageY,
        };
    };

    handleColorAreaPointerDown = (event: PointerEvent) => {
        this.isPointerDown = true;
        // Set pointer capture to ensure events keep coming to this element
        this.colorArea.setPointerCapture(event.pointerId);
        this.moveMarker(event);
    };

    handleMarkerPointerDown = (event: PointerEvent) => {
        this.isPointerDown = true;
        // Set pointer capture to ensure events keep coming to this element
        this.colorMarker.setPointerCapture(event.pointerId);
        event.stopPropagation();
    };

    handlePointerMove = (event: PointerEvent) => {
        if (this.isPointerDown) {
            this.moveMarker(event);
        }
    };

    handlePointerUp = (event: PointerEvent) => {
        this.isPointerDown = false;
        // Release pointer capture
        if (this.colorArea && event.pointerId) {
            try {
                this.colorArea.releasePointerCapture(event.pointerId);
            } catch (e) {
                // Silently catch if the pointerId is no longer valid
            }
        }
        if (this.colorMarker && event.pointerId) {
            try {
                this.colorMarker.releasePointerCapture(event.pointerId);
            } catch (e) {
                // Silently catch if the pointerId is no longer valid
            }
        }
    };

    moveMarker = (event: PointerEvent) => {
        const pointer = this.getPointerPosition(event);
        let x = pointer.pageX - this.colorAreaDims.x;
        let y = pointer.pageY - this.colorAreaDims.y;
        this.setMarkerPosition(x, y);
    };

    setMarkerPosition = (x: number, y: number) => {
        // Make sure the marker doesn't go out of bounds
        x = x < 0 ? 0 : x > this.colorAreaDims.width ? this.colorAreaDims.width : x;
        y = y < 0 ? 0 : y > this.colorAreaDims.height ? this.colorAreaDims.height : y;

        // Update state
        this.markerPosition = { x, y };
        this.updateMarkerPosition();
        this.updateColorFromPosition();
    };

    updateMarkerPosition = () => {
        if (this.colorMarker) {
            this.colorMarker.style.left = `${this.markerPosition.x}px`;
            this.colorMarker.style.top = `${this.markerPosition.y}px`;
        }
    };

    updateColorFromPosition = () => {
        // Get the current HSV values
        const { h, s, v } = this.getCurrentHSV();

        // Convert to RGBA
        // const rgba =null// HSVAtoRGBA({ h, s, v, a: this.alpha });

        // // Convert to HEX
        // this.hexColor = RGBAToHex(rgba);

        // Store the opaque version (without alpha)
        this.opaqueHexColor = this.hexColor.substring(0, 7);

        // Create the color string
        const colorString = `hsla(${h}, ${s}%, ${v}%, ${this.alpha})`;
        this.currentColor = colorString;

        // Update color marker color
        if (this.colorMarker) {
            this.colorMarker.style.color = this.opaqueHexColor;
        }

        // Update alpha slider elements
        this.updateAlphaUI();

        // Update the color preview and hex input
        this.updateColorPreview();

        // Force repaint the gradients to fix Chrome bug
        this.forceGradientRepaint();

        // Emit color change event (like coloris.js onChange)
        this.colorChange.emit(this.hexColor);
    };

    onColorAdddedEvent = () => {
        this.swatches = [...this.swatches, this.hexColor];
        this.colorAdded.emit(this.hexColor);
    }

    onSwatchSelected = (color: string) => {
        if (this.editMode) {
            const index = this.swatches.findIndex(swatch => swatch === color);
            this.swatches.splice(index, 1);
            this.swatches = [...this.swatches];
        } else {
            this.colorSelected.emit(color)
        }
    }


    render() {
        return (
            <Host>
                <div class="clr-picker" ref={el => (this.pickerEl = el as HTMLElement)}>
                    <div id="clr-color-area" class="clr-gradient" role="application" ref={el => (this.colorArea = el as HTMLElement)}>
                        <div id="clr-color-marker" class="clr-marker" tabindex="0" ref={el => (this.colorMarker = el as HTMLElement)}></div>
                    </div>

                    <div class="clr-hue">
                        <input id="clr-hue-slider" type="range" min="0" max="360" step="1" aria-label="Hue slider" ref={el => (this.hueSlider = el as HTMLInputElement)} />
                        <div id="clr-hue-marker" ref={el => (this.hueMarker = el as HTMLElement)}></div>
                    </div>

                    <div class="clr-alpha">
                        <input id="clr-alpha-slider" type="range" min="0" max="100" step="1" aria-label="Opacity slider" ref={el => (this.alphaSlider = el as HTMLInputElement)} />
                        <div id="clr-alpha-marker" ref={el => (this.alphaMarker = el as HTMLElement)}></div>
                        <span ref={el => (this.alphaGradient = el as HTMLElement)}></span>
                    </div>

                    <div class="clr-info">
                        <button id="clr-color-preview" class="clr-preview" type="button" aria-label="Current color" ref={el => (this.colorPreview = el as HTMLElement)}></button>
                        <input id="clr-color-value" class="clr-color" type="text" aria-label="Color value field" ref={el => (this.colorValue = el as HTMLInputElement)} />
                    </div>

                    <div class="clr-swatches">
                        {this.swatches.map(swatch => (
                            <button style={{ backgroundColor: swatch }} class='clr-swatch' onClick={() => this.onSwatchSelected(swatch)}>
                                {this.editMode && <icon-trash class='icon-trash'></icon-trash>}
                            </button>))}
                        {this.editMode && <button class='clr-add' onClick={this.onColorAdddedEvent}><icon-add></icon-add></button>}
                    </div>
                </div>
            </Host>
        );
    }
}



